/**
 * Minified by jsDelivr using Terser v5.39.0.
 * Original file: /npm/dockview-core@4.7.1/dist/esm/events.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
export var Event;!function(t){t.any=(...t)=>e=>{const s=t.map((t=>t(e)));return{dispose:()=>{s.forEach((t=>{t.dispose()}))}}}}(Event||(Event={}));export class DockviewEvent{constructor(){this._defaultPrevented=!1}get defaultPrevented(){return this._defaultPrevented}preventDefault(){this._defaultPrevented=!0}}export class AcceptableEvent{constructor(){this._isAccepted=!1}get isAccepted(){return this._isAccepted}accept(){this._isAccepted=!0}}class LeakageMonitor{constructor(){this.events=new Map}get size(){return this.events.size}add(t,e){this.events.set(t,e)}delete(t){this.events.delete(t)}clear(){this.events.clear()}}class Stacktrace{static create(){var t;return new Stacktrace(null!==(t=(new Error).stack)&&void 0!==t?t:"")}constructor(t){this.value=t}print(){console.warn("dockview: stacktrace",this.value)}}class Listener{constructor(t,e){this.callback=t,this.stacktrace=e}}export class Emitter{static setLeakageMonitorEnabled(t){t!==Emitter.ENABLE_TRACKING&&Emitter.MEMORY_LEAK_WATCHER.clear(),Emitter.ENABLE_TRACKING=t}get value(){return this._last}constructor(t){this.options=t,this._listeners=[],this._disposed=!1}get event(){return this._event||(this._event=t=>{var e;(null===(e=this.options)||void 0===e?void 0:e.replay)&&void 0!==this._last&&t(this._last);const s=new Listener(t,Emitter.ENABLE_TRACKING?Stacktrace.create():void 0);return this._listeners.push(s),{dispose:()=>{const t=this._listeners.indexOf(s);t>-1?this._listeners.splice(t,1):Emitter.ENABLE_TRACKING}}},Emitter.ENABLE_TRACKING&&Emitter.MEMORY_LEAK_WATCHER.add(this._event,Stacktrace.create())),this._event}fire(t){var e;(null===(e=this.options)||void 0===e?void 0:e.replay)&&(this._last=t);for(const e of this._listeners)e.callback(t)}dispose(){this._disposed||(this._disposed=!0,this._listeners.length>0&&(Emitter.ENABLE_TRACKING&&queueMicrotask((()=>{var t;for(const e of this._listeners)console.warn("dockview: stacktrace",null===(t=e.stacktrace)||void 0===t?void 0:t.print())})),this._listeners=[]),Emitter.ENABLE_TRACKING&&this._event&&Emitter.MEMORY_LEAK_WATCHER.delete(this._event))}}Emitter.ENABLE_TRACKING=!1,Emitter.MEMORY_LEAK_WATCHER=new LeakageMonitor;export function addDisposableListener(t,e,s,i){return t.addEventListener(e,s,i),{dispose:()=>{t.removeEventListener(e,s,i)}}}export class AsapEvent{constructor(){this._onFired=new Emitter,this._currentFireCount=0,this._queued=!1,this.onEvent=t=>{const e=this._currentFireCount;return this._onFired.event((()=>{this._currentFireCount>e&&t()}))}}fire(){this._currentFireCount++,this._queued||(this._queued=!0,queueMicrotask((()=>{this._queued=!1,this._onFired.fire()})))}dispose(){this._onFired.dispose()}}
//# sourceMappingURL=/sm/53987db776e20e6bc5c0c5207c37a0c3066873020284a08cd035eb4e4da2b6f5.map